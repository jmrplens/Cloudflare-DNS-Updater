#!/bin/bash
# Monolith build generated by tools/bundle.sh

# --- Module: src/logger.sh ---

# Logger Module
# Supports Console (Colored) and File Logging (Plain)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
dGRAY='\033[1;30m'
NC='\033[0m' # No Color

LOG_FILE=""

# Initialize Logger
# Usage: logger_init "/path/to/logfile.log"
logger_init() {
	local log_path="$1"
	local log_dir
	log_dir=$(dirname "$log_path")

	# Create directory if needed
	if [[ ! -d "$log_dir" ]]; then
		mkdir -p "$log_dir" 2>/dev/null
	fi

	LOG_FILE="$log_path"

	# Rotation (Max 1MB)
	local max_size=$((1024 * 1024))
	if [[ -f "$LOG_FILE" ]]; then
		local size
		# Compatible size check using wc -c for portability
		size=$(wc -c <"$LOG_FILE" 2>/dev/null)
		size=${size//[[:space:]]/} # trim whitespace

		if [[ $size -gt $max_size ]]; then
			mv "$LOG_FILE" "${LOG_FILE}.old"
			# simple header
			echo "[$(date '+%Y-%m-%d %H:%M:%S')] Log rotated." >"$LOG_FILE"
		fi
	else
		touch "$LOG_FILE" 2>/dev/null
	fi
}

# Generic Log Function
# Args: level_color level_label message is_error
_log() {
	local color="$1"
	local label="$2"
	local msg="$3"
	local is_error="$4"
	local timestamp
	timestamp=$(date '+%Y-%m-%d %H:%M:%S')

	# Console Output (Colored)
	# Output to stderr (always, to avoid corrupting stdout when used in subshells)
	if ! is_silent || [[ "$is_error" == "true" ]]; then
		echo -e "${color}[${label}]${NC} ${msg}" >&2
	fi

	# File Output (Plain, if init)
	if [[ -n "$LOG_FILE" && -f "$LOG_FILE" ]]; then
		echo "[${timestamp}] [${label}] ${msg}" >>"$LOG_FILE"
	fi
}

log_info() {
	_log "$BLUE" "INFO" "$1" "false"
}

log_success() {
	_log "$GREEN" "OK" "$1" "false"
}

log_warn() {
	_log "$YELLOW" "WARN" "$1" "false"
}

log_error() {
	_log "$RED" "ERROR" "$1" "true"
}

log_debug() {
	if is_debug; then
		_log "$dGRAY" "DEBUG" "$1" "false"
	fi
}

# Boolean Helpers
is_debug() {
	[[ "${DEBUG:-false}" == "true" ]]
}

is_silent() {
	[[ "${SILENT:-false}" == "true" ]]
}

is_force() {
	[[ "${FORCE:-false}" == "true" ]]
}

# Helper to sanitize logs
sanitize_log() {
	local msg="$1"
	# Redact API Token
	if [[ -n "$CF_API_TOKEN" ]]; then
		msg="${msg//$CF_API_TOKEN/********}"
	fi
	# Redact Zone ID (optional, but good practice if requested)
	if [[ -n "$CF_ZONE_ID" ]]; then
		msg="${msg//$CF_ZONE_ID/********}"
	fi
	echo "$msg"
}

log_debug_redacted() {
	if is_debug; then
		local clean_msg
		clean_msg=$(sanitize_log "$1")
		_log "$dGRAY" "DEBUG" "$clean_msg" "false"
	fi
}

# --- Module: src/network.sh ---

# Network Helper Module
# Provides a unified http_request function wrapping curl, wget, or other tools.

# Check availability
if command -v curl >/dev/null 2>&1; then
	HTTP_CLIENT="curl"
elif command -v wget >/dev/null 2>&1; then
	HTTP_CLIENT="wget"
elif command -v powershell.exe >/dev/null 2>&1; then
	HTTP_CLIENT="powershell"
else
	# Try finding windows curl if in WSL/Git Bash
	if command -v curl.exe >/dev/null 2>&1; then
		HTTP_CLIENT="curl.exe"
	else
		HTTP_CLIENT=""
	fi
fi

# Universal HTTP Request function
# Usage: http_request "METHOD" "URL" "BODY" "HEADER1" "HEADER2" ...
# Returns: Response body on stdout, Status code 0 on success, 1 on failure.
# Note: For simple GET, BODY can be empty string "".
http_request() {
	local method="$1"
	local url="$2"
	local body="$3"
	shift 3
	local headers=("$@")

	if [[ -z "$HTTP_CLIENT" ]]; then
		echo "Error: No compatible HTTP client found (curl, wget or powershell)." >&2
		return 1
	fi

	if [[ "$HTTP_CLIENT" == "curl" || "$HTTP_CLIENT" == "curl.exe" ]]; then
		# Build curl command array
		local cmd=("$HTTP_CLIENT" "-s" "-X" "$method")

		# Add headers
		for h in "${headers[@]}"; do
			cmd+=("-H" "$h")
		done

		# Add body if present
		if [[ -n "$body" ]]; then
			cmd+=("-d" "$body")
		fi

		# Add URL
		cmd+=("$url")

		# Execute
		"${cmd[@]}"
		return $?

	elif [[ "$HTTP_CLIENT" == "wget" ]]; then
		# wget usage
		local cmd=("wget" "-q" "-O" "-")
		cmd+=("--method=$method")

		# Headers
		for h in "${headers[@]}"; do
			cmd+=("--header=$h")
		done

		# Body
		if [[ -n "$body" ]]; then
			cmd+=("--body-data=$body")
		fi

		cmd+=("--timeout=10")
		cmd+=("$url")

		"${cmd[@]}"
		return $?

	elif [[ "$HTTP_CLIENT" == "powershell" ]]; then
		# Windows PowerShell fallback
		local h_json="@{"
		for h in "${headers[@]}"; do
			local key="${h%%:*}"
			local val="${h#*: }"
			h_json+="'$key'='$val';"
		done
		h_json+="}"

		local ps_cmd="Invoke-RestMethod -Uri '$url' -Method $method -Headers $h_json"
		if [[ -n "$body" ]]; then
			# Escape single quotes in body for PS
			local escaped_body="${body//\'/''}"
			ps_cmd+=" -Body '$escaped_body'"
		fi

		powershell.exe -Command "$ps_cmd"
		return $?
	fi
}

# Simple helper for GET requests (wrapper)
# Usage: http_get "URL" [ipv4|ipv6|any]
# This replaces the old http_get in ip.sh
http_get() {
	local url="$1"
	local proto="${2:-any}"

	local ip_flag=""
	if [[ "$proto" == "4" || "$proto" == "ipv4" ]]; then
		if [[ "$HTTP_CLIENT" == "curl" || "$HTTP_CLIENT" == "curl.exe" ]]; then
			ip_flag="-4"
		elif [[ "$HTTP_CLIENT" == "wget" ]]; then ip_flag="-4"; fi
	elif [[ "$proto" == "6" || "$proto" == "ipv6" ]]; then
		if [[ "$HTTP_CLIENT" == "curl" || "$HTTP_CLIENT" == "curl.exe" ]]; then
			ip_flag="-6"
		elif [[ "$HTTP_CLIENT" == "wget" ]]; then ip_flag="-6"; fi
	fi

	if [[ "$HTTP_CLIENT" == "curl" || "$HTTP_CLIENT" == "curl.exe" ]]; then
		$HTTP_CLIENT -s "$ip_flag" --max-time 10 "$url"
	elif [[ "$HTTP_CLIENT" == "wget" ]]; then
		wget -q -O - "$ip_flag" --timeout=10 --tries=1 "$url"
	elif [[ "$HTTP_CLIENT" == "powershell" ]]; then
		# PowerShell doesn't have a simple flag for -4/-6 in Invoke-RestMethod easily for all versions
		# but usually it respects the OS preference.
		powershell.exe -Command "Invoke-RestMethod -Uri '$url'"
	fi
}

# --- Module: src/config.sh ---

# Global configuration variables
CF_ZONE_ID=""
CF_API_TOKEN=""
NET_INTERFACE=""
TG_ENABLED="false"
TG_BOT_TOKEN=""
TG_CHAT_ID=""
DISCORD_ENABLED="false"
DISCORD_WEBHOOK=""

# Domain arrays
domains_names=()
domains_proxied=()
domains_ipv4=()
domains_ipv6=()
domains_ttl=()
DOMAIN_COUNT=0

# Parse YAML config file
parse_config() {
	local yaml_file="$1"

	if [[ ! -f "$yaml_file" ]]; then
		log_error "Config file not found: $yaml_file"
		return 1
	fi

	# Check for syntax errors (basic)
	if grep -q $'\t' "$yaml_file"; then
		log_warn "Config file contains tabs. YAML forbids tabs. Proceeding, but parsing might fail."
	fi

	# Parse Global Settings
	CF_ZONE_ID=$(grep "zone_id:" "$yaml_file" | head -n1 | awk -F': ' '{print $2}' | tr -d ' "')
	CF_API_TOKEN=$(grep "api_token:" "$yaml_file" | head -n1 | awk -F': ' '{print $2}' | tr -d ' "')

	# Parse Options
	NET_INTERFACE=$(grep "interface:" "$yaml_file" | head -n1 | awk -F': ' '{print $2}' | tr -d ' "')

	TG_ENABLED=$(grep -A 5 "telegram:" "$yaml_file" | grep "enabled:" | head -n1 | awk -F': ' '{print $2}' | tr -d ' "')
	TG_BOT_TOKEN=$(grep -A 5 "telegram:" "$yaml_file" | grep "bot_token:" | head -n1 | awk -F': ' '{print $2}' | tr -d ' "')
	TG_CHAT_ID=$(grep -A 5 "telegram:" "$yaml_file" | grep "chat_id:" | head -n1 | awk -F': ' '{print $2}' | tr -d ' "')

	DISCORD_ENABLED=$(grep -A 5 "discord:" "$yaml_file" | grep "enabled:" | head -n1 | awk -F': ' '{print $2}' | tr -d ' "')
	DISCORD_WEBHOOK=$(grep -A 5 "discord:" "$yaml_file" | grep "webhook_url:" | head -n1 | awk -F': ' '{print $2}' | tr -d ' "')

	export CF_ZONE_ID CF_API_TOKEN NET_INTERFACE TG_ENABLED TG_BOT_TOKEN TG_CHAT_ID DISCORD_ENABLED DISCORD_WEBHOOK

	# Parse Domains Block
	domains_names=()
	domains_proxied=()
	domains_ipv4=()
	domains_ipv6=()
	domains_ttl=()

	local current_idx=-1
	local in_domains_block=false

	while IFS= read -r line || [[ -n "$line" ]]; do
		clean_line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

		# skip comments and empty lines
		if [[ "$clean_line" =~ ^# ]] || [[ -z "$clean_line" ]]; then
			continue
		fi

		if [[ "$clean_line" == "domains:" ]]; then
			in_domains_block=true
			continue
		fi

		if [[ "$clean_line" == "settings:" ]]; then
			in_domains_block=false
		fi

		if [[ "$in_domains_block" == "true" ]]; then
			# New domain entry
			if [[ "$line" =~ -[[:space:]]name:[[:space:]]*(.*) ]]; then
				current_idx=$((current_idx + 1))
				val="${BASH_REMATCH[1]}"
				domains_names[current_idx]="${val//\"/}" # remove quotes

				# Set defaults
				domains_proxied[current_idx]="true"
				domains_ipv4[current_idx]="true"
				domains_ipv6[current_idx]="true"
				domains_ttl[current_idx]="auto"
			fi

			# Parse properties
			if [[ $current_idx -ge 0 ]]; then
				if [[ "$clean_line" =~ ^proxied:[[:space:]]*(.*) ]]; then
					domains_proxied[current_idx]="${BASH_REMATCH[1]}"
				elif [[ "$clean_line" =~ ^ipv4:[[:space:]]*(.*) ]]; then
					domains_ipv4[current_idx]="${BASH_REMATCH[1]}"
				elif [[ "$clean_line" =~ ^ipv6:[[:space:]]*(.*) ]]; then
					domains_ipv6[current_idx]="${BASH_REMATCH[1]}"
				elif [[ "$clean_line" =~ ^ip_type:[[:space:]]*(.*) ]]; then
					val="${BASH_REMATCH[1]}"
					if [[ "$val" == "ipv4" ]]; then
						domains_ipv4[current_idx]="true"
						domains_ipv6[current_idx]="false"
					elif [[ "$val" == "ipv6" ]]; then
						domains_ipv4[current_idx]="false"
						domains_ipv6[current_idx]="true"
					elif [[ "$val" == "both" ]]; then
						domains_ipv4[current_idx]="true"
						domains_ipv6[current_idx]="true"
					fi
				elif [[ "$clean_line" =~ ^ttl:[[:space:]]*(.*) ]]; then
					domains_ttl[current_idx]="${BASH_REMATCH[1]}"
				fi
			fi
		fi

	done <"$yaml_file"

	export domains_names domains_proxied domains_ipv4 domains_ipv6 domains_ttl
	export DOMAIN_COUNT=${#domains_names[@]}
}

# --- Module: src/ip.sh ---

# Detect Default Interface (Linux/macOS)
get_default_interface() {
	if command -v ip >/dev/null 2>&1; then
		# Linux
		ip route show default | head -n1 | sed -n 's/.*dev \([^ ]*\).*/\1/p'
	elif command -v route >/dev/null 2>&1; then
		# macOS / BSD
		route -n get default | grep 'interface:' | awk '{print $2}'
	fi
}

# Get IPv6 from specific interface
get_ipv6_from_interface() {
	local iface="$1"
	local ip=""

	if [[ -z "$iface" ]]; then return 1; fi

	if command -v ip >/dev/null 2>&1; then
		# Linux: Prefer 'global' scope, exclude 'deprecated' or 'temporary' if possible,
		# but Cloudflare usually wants the permanent global address.
		# We take the first 'scope global' address.
		# 'ip -6 addr show dev eth0 scope global'
		# Output format: "inet6 2001:db8::1/64 scope global ..."

		# Try to find one that is NOT temporary (mngtmpaddr/dynamic) if possible,
		# or just the first global one.
		# User example: 2a0c:5a84:b906:6300:7a55:36ff:fe04:bb9a (looks like EUI-64 or random privacy, but global)

		ip=$(ip -6 addr show dev "$iface" scope global | grep "inet6" | head -n1 | awk '{print $2}' | cut -d'/' -f1)

	elif command -v ifconfig >/dev/null 2>&1; then
		# macOS / BSD
		# Look for 'inet6', exclude 'fe80', take first.
		ip=$(ifconfig "$iface" | grep "inet6 " | grep -v "fe80::" | head -n1 | awk '{print $2}' | cut -d'/' -f1)
	fi

	# Windows (via ipconfig in git bash/wsl? hard to parse reliable without powershell)
	# If standard tools fail, return empty.

	echo "$ip"
}

# IP Validation Helpers
is_valid_ipv4() {
	[[ "$1" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]
}

is_valid_ipv6() {
	[[ "$1" =~ ^[0-9a-fA-F:]+$ ]] && [[ "$1" == *":"* ]]
}

# Get Public IPv4
get_public_ipv4() {
	local ip=""
	# Try icanhazip
	ip=$(http_get "https://icanhazip.com" 4)

	if [[ -z "$ip" ]]; then
		# Try ifconfig.co
		ip=$(http_get "https://ifconfig.co" 4)
	fi
	if [[ -z "$ip" ]]; then
		# Try ipify
		ip=$(http_get "https://api.ipify.org" 4)
	fi

	# Validate IP format
	if is_valid_ipv4 "$ip"; then
		echo "$ip"
		return 0
	else
		echo ""
		return 1
	fi
}

# Get Public IPv6
get_public_ipv6() {
	local ip=""

	# 1. Try Local Interface (Preferred)
	local iface="${NET_INTERFACE}"

	# If no interface config, try to auto-detect default
	if [[ -z "$iface" ]]; then
		iface=$(get_default_interface)
	fi

	if [[ -n "$iface" ]]; then
		log_debug "Checking interface '$iface' for IPv6..."
		local local_ip
		local_ip=$(get_ipv6_from_interface "$iface")

		if [[ -n "$local_ip" ]]; then
			log_debug "Found Local IPv6: $local_ip"
			echo "$local_ip"
			return 0
		else
			log_debug "No Global IPv6 found on interface '$iface'."
		fi
	fi

	# 2. Fallback to External Services
	log_debug "Fallback to external IPv6 detection..."

	# Try icanhazip
	ip=$(http_get "https://icanhazip.com" 6)

	if [[ -z "$ip" ]]; then
		# Try ifconfig.co
		ip=$(http_get "https://ifconfig.co" 6)
	fi

	# Validate IP format
	if is_valid_ipv6 "$ip"; then
		echo "$ip"
		return 0
	else
		echo ""
		return 1
	fi
}

# --- Module: src/cloudflare.sh ---

CF_API_URL="https://api.cloudflare.com/client/v4"

# Fetch all records (limit 500)
cf_get_all_records() {
	log_debug "API: GET $CF_API_URL/zones/$CF_ZONE_ID/dns_records?per_page=500"

	response=$(http_request "GET" \
		"$CF_API_URL/zones/$CF_ZONE_ID/dns_records?per_page=500" \
		"" \
		"Authorization: Bearer $CF_API_TOKEN" \
		"Content-Type: application/json")

	log_debug_redacted "API Response: $response"

	if [[ "$response" != *"\"success\":true"* ]]; then
		log_error "Failed to fetch records"
		log_debug_redacted "$response"
		return 1
	fi

	echo "$response"
}

# Parse JSON response into flat readable lines:
# ID|NAME|TYPE|CONTENT|PROXIED
cf_parse_records_to_lines() {
	local json="$1"

	# Determine JSON parser
	local jq_cmd="jq"
	if command -v jq &>/dev/null; then
		jq_cmd="jq"
	elif command -v jq.exe &>/dev/null; then
		jq_cmd="jq.exe"
	elif [[ -f "/mnt/c/msys64/mingw64/bin/jq.exe" ]]; then
		jq_cmd="/mnt/c/msys64/mingw64/bin/jq.exe"
	elif [[ -f "/c/msys64/mingw64/bin/jq.exe" ]]; then
		jq_cmd="/c/msys64/mingw64/bin/jq.exe"
	else
		jq_cmd=""
	fi

	# Parse
	if [[ -n "$jq_cmd" ]]; then
		log_debug "Using JSON parser: $jq_cmd"
		echo "$json" | "$jq_cmd" -r '.result[] | "\(.id)|\(.name)|\(.type)|\(.content)|\(.proxied)"'
	else
		log_warn "jq not found. Using sed parser fallback."

		echo "$json" |
			sed -e 's/},{"/}\n{/g' |
			sed -e 's/\[{/{/g' |
			sed -e 's/}\]//g' |
			while read -r line; do
				id=$(echo "$line" | grep -o '"id":"[^"]*"' | head -n1 | cut -d'"' -f4)
				name=$(echo "$line" | grep -o '"name":"[^"]*"' | head -n1 | cut -d'"' -f4)
				type=$(echo "$line" | grep -o '"type":"[^"]*"' | head -n1 | cut -d'"' -f4)
				content=$(echo "$line" | grep -o '"content":"[^"]*"' | head -n1 | cut -d'"' -f4)
				proxied=$(echo "$line" | grep -o '"proxied":[^,}]*' | head -n1 | cut -d':' -f2 | tr -d ' ')

				if [[ -n "$id" && -n "$name" ]]; then
					echo "$id|$name|$type|$content|$proxied"
				fi
			done
	fi
}

# Batch Update
cf_batch_update() {
	local payload="$1"

	log_debug "API: POST batch update..."
	log_debug_redacted "API Payload: $payload"

	response=$(http_request "POST" \
		"$CF_API_URL/zones/$CF_ZONE_ID/dns_records/batch" \
		"$payload" \
		"Authorization: Bearer $CF_API_TOKEN" \
		"Content-Type: application/json")

	log_debug_redacted "API Response: $response"

	# Echo response for caller to capture
	echo "$response"

	if [[ "$response" == *"\"success\":true"* ]]; then
		return 0
	else
		log_error "Batch update failed!"
		log_debug_redacted "$response"
		return 1
	fi
}

# Cache Helper
# Args: parsed_records domain type
cf_get_record_from_cache() {
	local cache="$1"
	local domain="$2"
	local type="$3"
	echo "$cache" | grep -F "|$domain|$type|" | head -n1
}

# Comparison Helper
# Args: current_ip target_ip current_proxied target_proxied
cf_needs_update() {
	local cur_ip="$1"
	local tar_ip="$2"
	local cur_proxied="$3"
	local tar_proxied="$4"

	[[ "$cur_ip" != "$tar_ip" ]] || [[ "$cur_proxied" != "$tar_proxied" ]]
}

# Helper to build a single update object JSON
cf_build_put_object() {
	local id="$1"
	local type="$2"
	local name="$3"
	local content="$4"
	local proxied="$5"
	local ttl="$6"

	if [[ "$ttl" == "auto" ]]; then ttl=1; fi

	# Returns: {"id":"...","type":"...","name":"...","content":"...","ttl":...,"proxied":...}
	echo "{\"id\":\"$id\",\"type\":\"$type\",\"name\":\"$name\",\"content\":\"$content\",\"ttl\":$ttl,\"proxied\":$proxied}"
}

# --- Module: src/notifications.sh ---

send_notification() {
	local message="$1"

	# Telegram
	if [[ "$TG_ENABLED" == "true" ]]; then
		if [[ -n "$TG_BOT_TOKEN" && -n "$TG_CHAT_ID" ]]; then
			# Simple body construction (Telegram supports URL-encoded POST)
			local body="chat_id=${TG_CHAT_ID}&text=${message}"
			http_request "POST" "https://api.telegram.org/bot$TG_BOT_TOKEN/sendMessage" "$body" >/dev/null
		fi
	fi

	# Discord
	if [[ "$DISCORD_ENABLED" == "true" ]]; then
		if [[ -n "$DISCORD_WEBHOOK" ]]; then
			local body="{\"content\": \"$message\"}"
			http_request "POST" "$DISCORD_WEBHOOK" "$body" "Content-Type: application/json" >/dev/null
		fi
	fi
}

# --- Module: src/main.sh ---

# Load Modules

# Initialize Logger
LOG_PATH="$DIR/../logs/updater.log"
logger_init "$LOG_PATH"


# Global State for updates
updates_json_list=""
update_count=0
verification_list=()

# Helper to check and queue updates
queue_if_changed() {
	local type="$1"
	local domain="$2"
	local target_ip="$3"
	local target_proxied="$4"
	local ttl="$5"

	if [[ -z "$target_ip" ]]; then
		log_debug "  - IPv$([[ "$type" == "A" ]] && echo 4 || echo 6) Check skipped: No Public IP detected."
		return
	fi

	local match
	match=$(cf_get_record_from_cache "$parsed_records" "$domain" "$type")

	if [[ -z "$match" ]]; then
		log_warn "Record $type for $domain not found. Creation not implemented."
		return
	fi

	IFS='|' read -r r_id _ _ r_content r_proxied <<<"$match"

	if is_force || cf_needs_update "$r_content" "$target_ip" "$r_proxied" "$target_proxied"; then
		if is_force && ! cf_needs_update "$r_content" "$target_ip" "$r_proxied" "$target_proxied"; then
			log_info "Force update: $domain ($type) [Matches current: $target_ip]"
		else
			log_info "Change detected for $domain ($type): $r_content -> $target_ip"
		fi

		local obj
		obj=$(cf_build_put_object "$r_id" "$type" "$domain" "$target_ip" "$target_proxied" "$ttl")

		if [[ -n "$updates_json_list" ]]; then updates_json_list+=","; fi
		updates_json_list+="$obj"
		((update_count++))

		if [[ "$target_proxied" == "false" ]]; then
			verification_list+=("$domain|$([[ "$type" == "A" ]] && echo 4 || echo 6)|$target_ip")
		fi
	else
		log_debug "  - $type record OK ($r_content)"
	fi
}

main() {
	local config="$1"

	log_info "Starting Cloudflare DNS Updater..."

	# 1. Parse Config
	log_info "Loading configuration from $config..."
	if ! parse_config "$config"; then
		exit 1
	fi
	log_success "Loaded $DOMAIN_COUNT domains."

	# 2. Get Current Public IPs
	log_info "Detecting Public IPs..."
	CURRENT_IPV4=$(get_public_ipv4)
	CURRENT_IPV6=$(get_public_ipv6)

	if [[ -n "$CURRENT_IPV4" ]]; then log_success "Detected IPv4: $CURRENT_IPV4"; else log_warn "Could not detect Public IPv4."; fi
	if [[ -n "$CURRENT_IPV6" ]]; then log_success "Detected IPv6: $CURRENT_IPV6"; else log_info "Could not detect Public IPv6."; fi

	if [[ -z "$CURRENT_IPV4" && -z "$CURRENT_IPV6" ]]; then
		log_error "No connectivity or unable to detect any IP. Exiting."
		exit 1
	fi

	# 3. Fetch All Cloudflare Records
	log_info "Fetching all DNS records from Cloudflare..."
	if ! raw_records=$(cf_get_all_records); then
		log_error "Critical: Unable to fetch DNS records."
		exit 1
	fi

	parsed_records=$(cf_parse_records_to_lines "$raw_records")
	local record_lines
	record_lines=$(echo "$parsed_records" | wc -l)
	log_info "Parsed $record_lines records from Cloudflare (processing $DOMAIN_COUNT domains)."

	# 4. Analyze Records
	log_info "Analyzing records..."

	for ((i = 0; i < DOMAIN_COUNT; i++)); do
		local domain="${domains_names[i]}"
		local proxied="${domains_proxied[i]}"
		local ttl="${domains_ttl[i]}"

		log_debug "Checking domain: $domain (Proxy: $proxied)"

		# Check IPv4 if enabled
		if [[ "${domains_ipv4[i]}" == "true" ]]; then
			queue_if_changed "A" "$domain" "$CURRENT_IPV4" "$proxied" "$ttl"
		fi

		# Check IPv6 if enabled
		if [[ "${domains_ipv6[i]}" == "true" ]]; then
			queue_if_changed "AAAA" "$domain" "$CURRENT_IPV6" "$proxied" "$ttl"
		fi
	done

	# 5. Execute Batch Update
	if [[ $update_count -gt 0 ]]; then
		log_info "Pushing $update_count updates to Cloudflare..."

		local final_payload="{\"puts\":[$updates_json_list]}"
		local batch_response

		if batch_response=$(cf_batch_update "$final_payload"); then
			log_success "Successfully updated $update_count records!"
			send_notification "Cloudflare DNS: Updated $update_count records to IP(s) $CURRENT_IPV4 $CURRENT_IPV6"

			# --- Verification ---
			if is_debug; then
				log_info "Debug: Verifying updates via API response..."
				for item in "${verification_list[@]}"; do
					IFS='|' read -r v_domain v_proto v_expected <<<"$item"
					if echo "$batch_response" | grep -Fq "\"name\":\"$v_domain\"" && echo "$batch_response" | grep -Fq "\"content\":\"$v_expected\""; then
						log_success "API Verified: $v_domain (IPv$v_proto) confirmed updated to $v_expected"
					else
						log_warn "API Verification Warning: Could not confirm update for $v_domain in response."
					fi
				done
			fi
		else
			log_error "Batch update failed."
			send_notification "Cloudflare DNS: Batch update failed."
		fi
	else
		log_success "No changes needed. All records are up to date."
	fi
}

# Run

# --- Wrapper Logic ---



# Resolve directory (Monolith is self-contained)



DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"



# For makeself bundles, we need the original launching directory



ORIGINAL_PWD="${MAKESELF_PWD:-$PWD}"







# Initialize defaults



export SILENT="false"



export DEBUG="false"



export FORCE="false"



CONFIG_FILE=""







# Parse Arguments



for arg in "$@"; do



	case $arg in



	-s | --silent)



		export SILENT="true"



		;;



	-d | --debug)



		export DEBUG="true"



		;;



	-f | --force)



		export FORCE="true"



		;;



	*)



		# Check if it's a file, either absolute or relative to ORIGINAL_PWD



		if [[ -f "$arg" ]] && [[ "$arg" == *.yaml ]]; then



			CONFIG_FILE="$arg"



		elif [[ -f "$ORIGINAL_PWD/$arg" ]] && [[ "$arg" == *.yaml ]]; then



			CONFIG_FILE="$ORIGINAL_PWD/$arg"



		fi



		;;



	esac



done







# Debug info



if [[ "$DEBUG" == "true" ]]; then



	echo "Debug: Bundle Directory (DIR): $DIR"



	echo "Debug: Original Directory (ORIGINAL_PWD): $ORIGINAL_PWD"



	echo "Debug: Config File (Resolved): $CONFIG_FILE"



fi







# Fallback config lookup



if [[ -z "$CONFIG_FILE" ]]; then



	if [[ -f "$ORIGINAL_PWD/cloudflare-dns.yaml" ]]; then



		CONFIG_FILE="$ORIGINAL_PWD/cloudflare-dns.yaml"



	elif [[ -f "$DIR/cloudflare-dns.yaml" ]]; then



		CONFIG_FILE="$DIR/cloudflare-dns.yaml"



	fi



fi



# --- LOCK MECHANISM ---

LOCKFILE="/tmp/cloudflare-dns-updater.lock"

if [[ ! -d "/tmp" ]]; then

	LOCKFILE="$DIR/cloudflare-dns-updater.lock"

fi



if [[ -f "$LOCKFILE" ]]; then

	PID=$(cat "$LOCKFILE")

	if ps -p "$PID" >/dev/null 2>&1; then

		echo "Script is already running (PID: $PID). Exiting."

		exit 1

	else

		echo "Found stale lock file (PID: $PID). Overwriting."

	fi

fi



echo $ >"$LOCKFILE"

trap 'rm -f "$LOCKFILE"' EXIT

# ----------------------



if [[ ! -f "$CONFIG_FILE" ]]; then

	echo "Error: Configuration file not found!"

	echo "Please provide a valid .yaml file as an argument or create 'cloudflare-dns.yaml' in the current directory."

	exit 1

fi



# Run Main

main "$CONFIG_FILE"

